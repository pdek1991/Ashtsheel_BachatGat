<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Situs Router Control Panel</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom styles for Lucide icons */
        .lucide {
            display: inline-block;
            vertical-align: middle;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }
        .lucide-check { width: 1.25rem; height: 1.25rem; } /* w-5 h-5 */
        .lucide-history { width: 1.25rem; height: 1.25rem; } /* w-5 h-5 */
        .lucide-chevron-left, .lucide-chevron-right { width: 1.25rem; height: 1.25rem; } /* w-5 h-5 */

        /* Override default scrollbar styles if needed for aesthetics */
        .max-h-80::-webkit-scrollbar, .max-h-60::-webkit-scrollbar {
            width: 8px;
        }
        .max-h-80::-webkit-scrollbar-track, .max-h-60::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .max-h-80::-webkit-scrollbar-thumb, .max-h-60::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* Tailwind gray-300 */
            border-radius: 10px;
        }
        .max-h-80::-webkit-scrollbar-thumb:hover, .max-h-60::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* Tailwind gray-400 */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4 font-sans text-gray-900 flex flex-col items-center">

    <div id="app" class="w-full max-w-6xl bg-white rounded-2xl shadow-xl p-6 md:p-8 space-y-6">
        <!-- Header -->
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 border-b pb-4 border-gray-200">
            <h1 class="text-3xl font-extrabold text-blue-700 tracking-tight mb-2 md:mb-0">
                Situs Router Control Panel
            </h1>
            <div class="flex space-x-3 mt-4 md:mt-0">
                <!-- Take Button -->
                <button id="takeButton" class="flex items-center px-4 py-2 rounded-full font-medium shadow-md transition-all duration-300 transform">
                    <i data-lucide="check" class="lucide lucide-check w-5 h-5 mr-2"></i>
                    Take
                </button>
                <!-- Undo Button -->
                <button id="undoButton" class="flex items-center px-4 py-2 rounded-full font-medium shadow-md transition-all duration-300 transform">
                    <i data-lucide="history" class="lucide lucide-history w-5 h-5 mr-2"></i>
                    Undo
                </button>
            </div>
        </div>

        <!-- Source and Destination Grids -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Sources Section -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-800 text-center" id="sourcesHeader">Sources (Page: Tech)</h2>
                <div id="sourcesContainer" class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-3 p-2 bg-gray-50 rounded-lg shadow-inner max-h-80 overflow-y-auto">
                    <!-- Source blocks will be injected here by JavaScript -->
                </div>
                <!-- Source Pagination Controls -->
                <div class="flex justify-center items-center space-x-2 mt-4">
                    <button id="prevPageButton" class="p-2 rounded-full bg-blue-100 text-blue-700 hover:bg-blue-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        <i data-lucide="chevron-left" class="lucide lucide-chevron-left w-5 h-5"></i>
                    </button>
                    <div id="paginationButtons" class="flex space-x-1">
                        <!-- Pagination page buttons will be injected here -->
                    </div>
                    <button id="nextPageButton" class="p-2 rounded-full bg-blue-100 text-blue-700 hover:bg-blue-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        <i data-lucide="chevron-right" class="lucide lucide-chevron-right w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <!-- Destinations Section -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-800 text-center">Destinations</h2>
                <div id="destinationsContainer" class="grid grid-cols-5 sm:grid-cols-6 lg:grid-cols-10 gap-3 p-2 bg-gray-50 rounded-lg shadow-inner max-h-80 overflow-y-auto">
                    <!-- Destination blocks will be injected here by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Salvo Options Section -->
        <div class="mt-8 pt-4 border-t border-gray-200 text-center">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Salvo Options</h2>
            <div id="salvoButtonsContainer" class="flex flex-wrap justify-center gap-4">
                <!-- Salvo buttons will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- Global State Variables ---
        let allSources = [];
        let allDestinations = [];
        let routingMap = new Map(); // Map<string, string> (Source -> Destination)
        let history = []; // Stores snapshots of routingMap (as array of entries for serialization)
        let currentPage = 1;
        const itemsPerPage = 25; // 25 sources per page

        let pendingSource = null; // Source selected by user, awaiting 'Take'
        let pendingDestination = null; // Destination selected by user, awaiting 'Take'

        let lastButtonActionTime = 0; // Timestamp of last Take/Undo/Salvo button press
        let buttonColorTimeoutId = null; // Holds setTimeout ID for button color reset

        // Page names for pagination
        const pageNames = ["Tech", "On Camera", "Edit Suite", "Control Room"];

        // Define Salvo configurations
        const salvos = [
            {
                name: "Salvo 1 (1:1)",
                description: "Routes Source 1 to Dest 1, Source 2 to Dest 2, ..., Source 100 to Dest 100",
                action: (sources, destinations) => {
                    const routes = [];
                    for (let i = 0; i < 100; i++) {
                        if (sources[i] && destinations[i]) {
                            routes.push({ source: sources[i], destination: destinations[i] });
                        }
                    }
                    return routes;
                }
            },
            {
                name: "Salvo 2 (Reverse)",
                description: "Routes Source 100 to Dest 1, Source 99 to Dest 2, and so on.",
                action: (sources, destinations) => {
                    const routes = [];
                    const numSources = sources.length;
                    const numDestinations = destinations.length;
                    for (let i = 0; i < numSources; i++) {
                        // Map Source[i] to Destination[numDestinations - 1 - i]
                        // e.g., Source 1 (index 0) -> Destination 100 (index 99)
                        // Source 100 (index 99) -> Destination 1 (index 0)
                        const targetDestIndex = numDestinations - 1 - i;
                        if (sources[i] && destinations[targetDestIndex]) {
                            routes.push({ source: sources[i], destination: destinations[targetDestIndex] });
                        }
                    }
                    return routes;
                }
            },
            {
                name: "Salvo 3 (Shifted)",
                description: "Routes Source 1 to Dest 2, Source 2 to Dest 3, etc.",
                action: (sources, destinations) => {
                    const routes = [];
                    for (let i = 0; i < 100; i++) {
                        if (sources[i] && destinations[(i + 1) % 100]) { // Shift by 1, wrap around
                            routes.push({ source: sources[i], destination: destinations[(i + 1) % 100] });
                        }
                    }
                    return routes;
                }
            }
        ];

        // --- DOM Elements ---
        const sourcesContainer = document.getElementById('sourcesContainer');
        const destinationsContainer = document.getElementById('destinationsContainer');
        const takeButton = document.getElementById('takeButton');
        const undoButton = document.getElementById('undoButton');
        const prevPageButton = document.getElementById('prevPageButton');
        const nextPageButton = document.getElementById('nextPageButton');
        const paginationButtonsContainer = document.getElementById('paginationButtons');
        const sourcesHeader = document.getElementById('sourcesHeader');
        const salvoButtonsContainer = document.getElementById('salvoButtonsContainer');

        // --- Helper Functions ---

        // Helper function to simulate an SNMP SET operation
        function simulateSnmpSet(source, destination) {
            console.log(`Simulating SNMP SET: Routing "${source}" to "${destination}"`);
            // In a real application, you would make an API call to your backend
            // which then communicates with the SNMP device.
            // Example: fetch('/api/snmp-set', { method: 'POST', body: JSON.stringify({ source, destination }) });
        }

        // Determines the button color class based on the last action time
        function getButtonColorClass() {
            const isActive = (Date.now() - lastButtonActionTime) < 5000 && lastButtonActionTime > 0;
            if (isActive) {
                return 'bg-green-600 text-white';
            }
            return 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200';
        }

        // Updates the class of a button based on its state (color and disabled)
        function updateButtonClass(buttonElement, isDisabled) {
            const baseClasses = 'flex items-center px-4 py-2 rounded-full font-medium shadow-md transition-all duration-300 transform';
            const dynamicClasses = getButtonColorClass();
            const disabledClasses = isDisabled ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105 active:scale-95';
            buttonElement.className = `${baseClasses} ${dynamicClasses} ${disabledClasses}`;
            buttonElement.disabled = isDisabled;
        }

        // Manages the 5-second button color timeout
        function resetButtonColorTimeout() {
            if (buttonColorTimeoutId) {
                clearTimeout(buttonColorTimeoutId);
            }
            lastButtonActionTime = Date.now();
            buttonColorTimeoutId = setTimeout(() => {
                lastButtonActionTime = 0; // Reset after 5 seconds
                updateUI(); // Re-render to update button colors
            }, 5000); // 5 seconds
        }

        // --- Render Functions ---

        function renderSources() {
            sourcesContainer.innerHTML = ''; // Clear existing sources

            const totalPages = Math.ceil(allSources.length / itemsPerPage);
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const currentSources = allSources.slice(startIndex, endIndex);

            sourcesHeader.textContent = `Sources (Page: ${pageNames[currentPage - 1] || `Page ${currentPage}`})`;

            currentSources.forEach(source => {
                const isHighlighted = source === pendingSource;
                // Check if this source is currently routed to the selected pending destination
                const isCurrentlyRoutingToSelectedDestination = pendingDestination && routingMap.get(source) === pendingDestination;

                const blockDiv = document.createElement('div');
                let blockClasses = `p-3 rounded-lg text-center font-medium transition-colors duration-200 cursor-pointer select-none`;

                if (isHighlighted) {
                    blockClasses += ' bg-red-500 text-white shadow-lg';
                } else if (isCurrentlyRoutingToSelectedDestination) {
                    blockClasses += ' bg-purple-200 text-purple-800 border-2 border-purple-500 shadow-md';
                } else {
                    blockClasses += ' bg-green-100 text-green-800 hover:bg-green-200';
                }

                blockDiv.className = blockClasses;
                blockDiv.textContent = source;
                blockDiv.dataset.source = source; // Store source name for event handling
                blockDiv.addEventListener('click', () => handleSourceClick(source));
                sourcesContainer.appendChild(blockDiv);
            });

            // Update pagination buttons
            paginationButtonsContainer.innerHTML = '';
            for (let i = 1; i <= totalPages; i++) {
                const pageButton = document.createElement('button');
                pageButton.textContent = pageNames[i - 1] || `Page ${i}`;
                pageButton.className = `px-3 py-1 rounded-full text-sm font-medium transition-colors ${
                    currentPage === i
                        ? 'bg-blue-600 text-white shadow-md'
                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                }`;
                pageButton.addEventListener('click', () => goToPage(i));
                paginationButtonsContainer.appendChild(pageButton);
            }

            prevPageButton.disabled = currentPage === 1;
            nextPageButton.disabled = currentPage === totalPages;
            prevPageButton.classList.toggle('opacity-50', currentPage === 1);
            prevPageButton.classList.toggle('cursor-not-allowed', currentPage === 1);
            nextPageButton.classList.toggle('opacity-50', currentPage === totalPages);
            nextPageButton.classList.toggle('cursor-not-allowed', currentPage === totalPages);
        }

        function renderDestinations() {
            destinationsContainer.innerHTML = ''; // Clear existing destinations

            allDestinations.forEach(destination => {
                const isHighlighted = destination === pendingDestination;
                const isCurrentDestinationForPendingSource =
                    pendingSource && routingMap.get(pendingSource) === destination && pendingDestination !== destination;

                const blockDiv = document.createElement('div');
                let blockClasses = `p-3 rounded-lg text-center font-medium transition-colors duration-200 cursor-pointer select-none`;

                if (isHighlighted) {
                    blockClasses += ' bg-red-500 text-white shadow-lg';
                } else if (isCurrentDestinationForPendingSource) {
                    blockClasses += ' bg-blue-300 text-blue-900 shadow-md border-2 border-blue-500';
                } else {
                    blockClasses += ' bg-orange-100 text-orange-800 hover:bg-orange-200';
                }

                blockDiv.className = blockClasses;
                blockDiv.textContent = destination;
                blockDiv.dataset.destination = destination; // Store destination name for event handling
                blockDiv.addEventListener('click', () => handleDestinationClick(destination));
                destinationsContainer.appendChild(blockDiv);
            });
        }

        function renderSalvoButtons() {
            salvoButtonsContainer.innerHTML = '';
            salvos.forEach((salvo, index) => {
                const button = document.createElement('button');
                button.textContent = salvo.name;
                button.title = salvo.description;
                button.className = `flex-1 min-w-[150px] md:flex-none px-6 py-3 rounded-full font-medium shadow-md transition-all duration-300 transform ${getButtonColorClass()} hover:scale-105 active:scale-95`;
                button.addEventListener('click', () => handleSalvo(salvo.action));
                salvoButtonsContainer.appendChild(button);
            });
        }

        // Central UI update function
        function updateUI() {
            renderSources();
            renderDestinations();

            const isUndoDisabled = history.length === 0 && (Date.now() - lastButtonActionTime) >= 5000;
            const isTakeDisabled = !pendingSource || !pendingDestination;

            updateButtonClass(takeButton, isTakeDisabled);
            updateButtonClass(undoButton, isUndoDisabled);

            renderSalvoButtons(); // Re-render salvo buttons to update their color
            lucide.createIcons(); // Re-render Lucide icons if any new elements are added
        }

        // --- Event Handlers ---

        function handleSourceClick(source) {
            pendingSource = source;
            // pendingDestination is NOT cleared here, allowing flexible selection order
            resetButtonColorTimeout();
            console.log(`Source selected: ${source}`);
            updateUI();
        }

        function handleDestinationClick(destination) {
            pendingDestination = destination;
            resetButtonColorTimeout();
            console.log(`Destination selected: ${destination}`);
            updateUI();
        }

        function handleTake() {
            if (pendingSource && pendingDestination) {
                // Save current routing map to history before updating
                history.push(Array.from(routingMap.entries()));

                // Update routing map
                routingMap.set(pendingSource, pendingDestination);

                simulateSnmpSet(pendingSource, pendingDestination);

                // Clear pending selections after "Take"
                pendingSource = null;
                pendingDestination = null;
                resetButtonColorTimeout();
                console.log("Take action performed. Configuration applied.");
                updateUI();
            } else {
                console.log("Please select both a source and a destination before taking.");
            }
        }

        function handleUndo() {
            if (history.length > 0) {
                const previousStateEntries = history.pop(); // Remove last history item
                routingMap = new Map(previousStateEntries);

                pendingSource = null; // Clear pending selections on undo
                pendingDestination = null; // Clear pending selections on undo
                resetButtonColorTimeout();
                console.log("Undo action performed. Reverted to previous routing state.");
                updateUI();
            }
        }

        function handleSalvo(salvoAction) {
            // Save current routing map to history before applying salvo
            history.push(Array.from(routingMap.entries()));

            const routesToApply = salvoAction(allSources, allDestinations);

            routesToApply.forEach(({ source, destination }) => {
                routingMap.set(source, destination);
                simulateSnmpSet(source, destination); // Simulate individual SNMP SETs
            });

            pendingSource = null; // Clear any pending selections
            pendingDestination = null; // Clear any pending selections
            resetButtonColorTimeout();
            console.log("Salvo applied.");
            updateUI();
        }

        // Pagination handlers
        function goToNextPage() {
            const totalPages = Math.ceil(allSources.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                pendingSource = null; // Clear selection on page change
                pendingDestination = null; // Clear selection on page change
                updateUI();
            }
        }

        function goToPreviousPage() {
            if (currentPage > 1) {
                currentPage--;
                pendingSource = null; // Clear selection on page change
                pendingDestination = null; // Clear selection on page change
                updateUI();
            }
        }

        function goToPage(pageNumber) {
            const totalPages = Math.ceil(allSources.length / itemsPerPage);
            if (pageNumber >= 1 && pageNumber <= totalPages) {
                currentPage = pageNumber;
                pendingSource = null; // Clear selection on page change
                pendingDestination = null; // Clear selection on page change
                updateUI();
            }
        }

        // --- Initialization ---
        function initApp() {
            // Initialize sources and destinations
            allSources = Array.from({ length: 100 }, (_, i) => `Source ${i + 1}`);
            allDestinations = Array.from({ length: 100 }, (_, i) => `Destination ${i + 1}`);

            // Initialize routing map: each source routed to its corresponding destination by default
            allSources.forEach((src, index) => {
                routingMap.set(src, allDestinations[index] || src); // Default route Source N to Destination N
            });

            // Attach event listeners to fixed buttons
            takeButton.addEventListener('click', handleTake);
            undoButton.addEventListener('click', handleUndo);
            prevPageButton.addEventListener('click', goToPreviousPage);
            nextPageButton.addEventListener('click', goToNextPage);

            // Initial UI render
            updateUI();
        }

        // Run initialization when the window loads
        window.onload = initApp;
    </script>
</body>
</html>

